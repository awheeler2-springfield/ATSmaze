<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ATS Resume Maze — Hybrid Experience (C)</title>

<style>
  body { font-family: Arial, sans-serif; margin: 0; display: flex; height: 100vh; }

  #rail {
    width: 360px;
    background: #1D3461;
    color: white;
    padding: 20px;
    box-sizing: border-box;
    overflow: auto;
  }

  #rail h2 { margin-top: 0; }
  .stat { margin: 8px 0; }
  .btnRow { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }

  button {
    cursor: pointer;
    border: none;
    padding: 10px 12px;
    font-weight: bold;
    border-radius: 6px;
  }
  #resetBtn { background: #FFFBF0; color: #1D3461; }
  #resetBtn:hover { filter: brightness(0.95); }

  #mazeWrap {
    flex: 1;
    background: #f5f5f5;
    padding: 30px;
    overflow: auto;
  }

  #mazeTitle {
    max-width: 980px;
    margin: 0 auto 12px auto;
    color: #333;
    font-weight: bold;
  }

  #maze {
    max-width: 980px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(4, 220px);
    gap: 14px;
    justify-content: center;
    align-content: start;
  }

  .node {
    background: white;
    border: 2px solid #ddd;
    padding: 10px 12px;
    text-align: center;
    cursor: pointer;
    font-weight: bold;
    transition: 0.15s ease;
    user-select: none;
    border-radius: 8px;
  }

  .visited { background: #FFFBF0; border-color: #C96A00; }
  .current { background: #F0FAFB; border-color: #0A6E6E; }
  .available { border-color: #0A6E6E; }
  .disabled { pointer-events: none; opacity: 0.35; }

  .tag {
    display: inline-block;
    font-weight: normal;
    font-size: 0.75rem;
    opacity: 0.8;
    margin-top: 6px;
  }

  #diagnostic {
    margin-top: 16px;
    font-size: 0.92rem;
    line-height: 1.35;
  }

  #pathBox {
    margin-top: 10px;
    font-size: 0.85rem;
    line-height: 1.3;
    opacity: 0.95;
  }
  #pathBox code {
    display: block;
    background: rgba(255,255,255,0.12);
    padding: 8px;
    border-radius: 6px;
    margin-top: 6px;
    word-break: break-word;
  }
</style>
</head>

<body>

<div id="rail">
  <h2>ATS Resume Maze</h2>

  <div class="stat"><strong>Moves:</strong> <span id="moveCount">0</span></div>
  <div class="stat"><strong>Score:</strong> <span id="score">100</span></div>
  <div class="stat"><strong>Best (this device):</strong> <span id="bestScore">—</span></div>

  <div class="btnRow">
    <button id="resetBtn" type="button">Reset Run</button>
  </div>

  <div id="pathBox">
    <strong>Path (this run):</strong>
    <code id="pathText">header</code>
  </div>

  <div id="diagnostic"></div>
</div>

<div id="mazeWrap">
  <div id="mazeTitle">Click only adjacent choices. Experience includes a fixed backbone + randomized side branches each run.</div>
  <div id="maze"></div>
</div>

<script type="module">
/* =========================================================
   HYBRID EXPERIENCE (C)
   - Fixed backbone path through Experience
   - Random side branches each run
   - End-only pedagogical report
========================================================= */

/* ---------- Best score persistence ---------- */
const BEST_KEY = "atsMazeBestScore";
function getBestScore() {
  const raw = localStorage.getItem(BEST_KEY);
  if (!raw) return null;
  const n = Number(raw);
  return Number.isFinite(n) ? n : null;
}
function setBestScoreIfHigher(score) {
  const best = getBestScore();
  if (best === null || score > best) localStorage.setItem(BEST_KEY, String(score));
}
function updateBestScoreUI() {
  const best = getBestScore();
  document.getElementById("bestScore").textContent = best === null ? "—" : String(best);
}

/* ---------- Trap explanations (end-only) ---------- */
const trapExplanations = {
  weak_verbs: "Weak or passive verbs reduce ATS keyword strength and clarity.",
  no_metrics: "No quantified impact reduces ranking and credibility signals.",
  generic_alignment: "Generic experience (not tailored) lowers match relevance.",
  tables_layout: "Tables/columns can scramble parsing and break field extraction.",
  graphics_icons: "Graphics/icons can hide text from ATS or introduce noise.",
  keyword_dump: "Keyword dumping can look spammy and reduce semantic match quality."
};

function trapLabel(type) {
  const map = {
    weak_verbs: "Weak Verbs",
    no_metrics: "No Metrics",
    generic_alignment: "Generic Alignment",
    tables_layout: "Tables/Columns",
    graphics_icons: "Graphics/Icons",
    keyword_dump: "Keyword Dumping"
  };
  return map[type] ?? type;
}

/* ---------- Graph + Nodes (rebuilt each run) ---------- */
let nodes = {};           // id -> { id, label, tag? }
let graph = {};           // id -> [neighborIds]
let experienceNodeIds = []; // for cleanup/regeneration

function addNode(id, label, tag = "") {
  nodes[id] = { id, label, tag };
  if (!graph[id]) graph[id] = [];
}

function connect(a, b) {
  if (!graph[a]) graph[a] = [];
  if (!graph[b]) graph[b] = [];
  if (!graph[a].includes(b)) graph[a].push(b);
  if (!graph[b].includes(a)) graph[b].push(a);
}

function validateGraph(g) {
  for (const node in g) {
    g[node].forEach(neighbor => {
      if (!g[neighbor] || !g[neighbor].includes(node)) {
        throw new Error(`Asymmetric edge: ${node} ↔ ${neighbor}`);
      }
    });
  }
}

/* ---------- Hybrid Experience generator ---------- */
function randInt(min, maxInclusive) {
  return Math.floor(Math.random() * (maxInclusive - min + 1)) + min;
}
function pick(arr) {
  return arr[randInt(0, arr.length - 1)];
}

function buildHybridGraph() {
  nodes = {};
  graph = {};
  experienceNodeIds = [];

  // Fixed spine (sections)
  addNode("header", "Header", "section");
  addNode("summary", "Summary", "section");
  addNode("skills", "Skills", "section");
  addNode("projects", "Projects", "section");
  addNode("certifications", "Certifications", "section");
  addNode("education", "Education", "section");

  connect("header", "summary");
  connect("summary", "skills");

  // Experience entry/exit nodes
  addNode("exp_entry", "Experience", "experience");
  addNode("exp_exit", "Exit Experience", "experience");

  connect("skills", "exp_entry");
  connect("exp_exit", "projects");

  // Fixed backbone through Experience (always solvable, always teachable)
  const backbone = [
    { id: "exp_b1", label: "Role + Company", tag: "backbone" },
    { id: "exp_b2", label: "Strong Action Verbs", tag: "backbone" },
    { id: "exp_b3", label: "Quantified Impact", tag: "backbone" },
    { id: "exp_b4", label: "Tailored Keywords", tag: "backbone" },
    { id: "exp_b5", label: "Clean Formatting", tag: "backbone" }
  ];

  backbone.forEach(n => {
    addNode(n.id, n.label, n.tag);
    experienceNodeIds.push(n.id);
  });

  connect("exp_entry", "exp_b1");
  connect("exp_b1", "exp_b2");
  connect("exp_b2", "exp_b3");
  connect("exp_b3", "exp_b4");
  connect("exp_b4", "exp_b5");
  connect("exp_b5", "exp_exit");

  // Randomized side branches (replay variety)
  // These represent choices that can be suboptimal (traps) but recoverable.
  const sideTypes = [
    { type: "weak_verbs", label: "Weak Verbs", tag: "trap" },
    { type: "no_metrics", label: "No Metrics", tag: "trap" },
    { type: "generic_alignment", label: "Generic Alignment", tag: "trap" },
    { type: "tables_layout", label: "Tables/Columns", tag: "trap" },
    { type: "graphics_icons", label: "Icons/Graphics", tag: "trap" },
    { type: "keyword_dump", label: "Keyword Dumping", tag: "trap" }
  ];

  // Attach 0–2 branches per backbone node (except the last)
  const attachPoints = ["exp_b1", "exp_b2", "exp_b3", "exp_b4"];
  let sideCounter = 0;

  for (const anchor of attachPoints) {
    const branchCount = randInt(0, 2);

    for (let i = 0; i < branchCount; i++) {
      sideCounter++;
      const t = pick(sideTypes);
      const sid = `exp_s${sideCounter}`;

      addNode(sid, t.label, `trap:${t.type}`);
      experienceNodeIds.push(sid);

      // Connect branch to anchor
      connect(anchor, sid);

      // Optional: make a tiny 2-step branch for variety
      if (Math.random() < 0.45) {
        sideCounter++;
        const t2 = pick(sideTypes);
        const sid2 = `exp_s${sideCounter}`;
        addNode(sid2, t2.label, `trap:${t2.type}`);
        experienceNodeIds.push(sid2);
        connect(sid, sid2);

        // Recovery back to the backbone one step ahead (keeps it playable)
        // e.g., exp_b2 branch can return to exp_b3
        const recoverMap = { exp_b1: "exp_b2", exp_b2: "exp_b3", exp_b3: "exp_b4", exp_b4: "exp_b5" };
        connect(sid2, recoverMap[anchor]);
      } else {
        // Single-step branch recovers back to same anchor (low-cost detour)
        connect(sid, anchor);
      }
    }
  }

  // Continue spine
  connect("projects", "certifications");
  connect("certifications", "education");

  validateGraph(graph);
}

/* ---------- State ---------- */
function createInitialState() {
  return {
    currentNode: "header",
    visited: new Set(["header"]),
    moves: 0,
    trapsHit: new Map(), // trapType -> count
    complete: false,
    path: ["header"]
  };
}

let state = createInitialState();

/* ---------- Engine ---------- */
function recordTrapHit(s, nodeId) {
  const tag = nodes[nodeId]?.tag ?? "";
  // trap tags look like "trap:weak_verbs"
  if (!tag.startsWith("trap:")) return;
  const type = tag.split(":")[1];
  s.trapsHit.set(type, (s.trapsHit.get(type) ?? 0) + 1);
}

function attemptMove(s, targetNode) {
  if (s.complete) return { success: false };
  if (!graph[s.currentNode]?.includes(targetNode)) return { success: false };

  s.moves++;
  s.currentNode = targetNode;
  s.visited.add(targetNode);
  s.path.push(targetNode);

  recordTrapHit(s, targetNode);

  if (targetNode === "education") s.complete = true;

  return { success: true };
}

function calculateScore(s) {
  // Replay-oriented: reward efficient navigation + avoid trap types
  const trapCountTotal = [...s.trapsHit.values()].reduce((a,b)=>a+b, 0);
  return Math.max(0, 100 - s.moves - (trapCountTotal * 8));
}

/* ---------- Renderer (rebuild DOM each run) ---------- */
const mazeEl = document.getElementById("maze");

function clearMazeDOM() {
  mazeEl.innerHTML = "";
}

function createNodeEl(id) {
  const el = document.createElement("div");
  el.className = "node";
  el.id = id;
  el.innerHTML = `
    <div>${nodes[id].label}</div>
    ${nodes[id].tag ? `<div class="tag">${nodes[id].tag}</div>` : ""}
  `;
  el.addEventListener("click", () => {
    const result = attemptMove(state, id);
    if (result.success) {
      render(state);
      updateRail(state);
    }
  });
  return el;
}

function buildMazeDOM() {
  clearMazeDOM();

  // Order for readability: spine first, then experience cluster, then exit spine.
  const spineTop = ["header", "summary", "skills"];
  const spineBottom = ["projects", "certifications", "education"];

  spineTop.forEach(id => mazeEl.appendChild(createNodeEl(id)));

  // Experience cluster ordering: entry, backbone, side nodes, exit
  const cluster = ["exp_entry", "exp_b1", "exp_b2", "exp_b3", "exp_b4", "exp_b5", "exp_exit"];
  cluster.forEach(id => mazeEl.appendChild(createNodeEl(id)));

  // Append all side nodes (in creation order)
  const sideIds = experienceNodeIds.filter(id => id.startsWith("exp_s"));
  sideIds.forEach(id => mazeEl.appendChild(createNodeEl(id)));

  spineBottom.forEach(id => mazeEl.appendChild(createNodeEl(id)));
}

function render(s) {
  document.querySelectorAll(".node").forEach(el => {
    el.classList.remove("visited", "current", "available", "disabled");
    el.classList.add("disabled");
  });

  s.visited.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add("visited");
  });

  const currentEl = document.getElementById(s.currentNode);
  if (currentEl) currentEl.classList.add("current");

  (graph[s.currentNode] ?? []).forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.classList.remove("disabled");
      el.classList.add("available");
    }
  });

  document.getElementById("pathText").textContent = s.path.join(" → ");
}

/* ---------- Rail + End report ---------- */
function updateRail(s) {
  const score = calculateScore(s);
  document.getElementById("moveCount").textContent = String(s.moves);
  document.getElementById("score").textContent = String(score);

  if (s.complete) {
    setBestScoreIfHigher(score);
    updateBestScoreUI();
    showDiagnostic(s, score);
  }
}

function showDiagnostic(s, score) {
  let html = `<h3>Run Summary</h3>
    <p><strong>Final score:</strong> ${score}</p>
    <p><strong>Moves:</strong> ${s.moves}</p>`;

  const trapTypes = [...s.trapsHit.keys()];
  if (trapTypes.length === 0) {
    html += `<p><strong>ATS flags:</strong> none</p>
             <p>You stayed on the backbone: strong verbs, metrics, tailoring, and clean formatting.</p>`;
  } else {
    html += `<p><strong>ATS flags triggered:</strong> ${trapTypes.length}</p>`;
    trapTypes.forEach(type => {
      const count = s.trapsHit.get(type);
      html += `<p><strong>${trapLabel(type)} (x${count}):</strong> ${trapExplanations[type] ?? "—"}</p>`;
    });
    html += `<p style="margin-top:10px; opacity:0.95;">Replay goal: fewer moves + fewer flag types.</p>`;
  }

  document.getElementById("diagnostic").innerHTML = html;
}

/* ---------- Reset (rebuild hybrid graph) ---------- */
function resetRun() {
  buildHybridGraph();
  buildMazeDOM();

  state = createInitialState();
  document.getElementById("diagnostic").innerHTML = "";

  render(state);
  updateRail(state);
}

/* ---------- Init ---------- */
updateBestScoreUI();
resetRun();

document.getElementById("resetBtn").addEventListener("click", resetRun);
</script>

</body>
</html>
